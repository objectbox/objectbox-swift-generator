// swiftlint:disable all
import ObjectBox

// MARK: - Entity metadata

{% for entity in entities where not entity.isEntitySubclass %}
extension {{ entity.className }}: Entity {}
{% endfor %}

{% for entity in entities %}
extension {{ entity.className }}: __EntityRelatable {
    {{ visibility }} typealias EntityType = {{ entity.className }}

    {{ visibility }} var _id: Id<{{ entity.className }}> {
        return self.{{ entity.idProperty.propertyName }}
    }
}

extension {{ entity.className }}: EntityInspectable {
    {{ visibility }} typealias CursorBaseType = {{ entity.className }}Cursor

    /// Generated metadata used by ObjectBox to persist the entity.
    {{ visibility }} static var entityInfo: EntityInfo {
        return EntityInfo(name: "{{ entity.name }}")
    }

    fileprivate static func buildEntity(modelBuilder: ModelBuilder) {
        let entityBuilder = modelBuilder.entityBuilder(for: entityInfo, id: {{ entity.modelId }}, uid: {{ entity.modelUid }})
        {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        {% set indexParam %}{% if prop.modelIndexId %}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }}{% endif %}{% endset %}
        entityBuilder.addProperty(name: "{{ prop.name }}", type: {{ prop.unwrappedPropertyType }}.entityPropertyType{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}{{ indexParam }})
        {% endfor %}

        {% for prop in entity.properties where prop.isRelation %}
        entityBuilder.addRelation(name: "{{ prop.name }}", targetEntityInfo: {{ prop.propertyType }}.Target.entityInfo{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }})
        {% endfor %}
    }
}

extension {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}{{ entity.className }}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}{{ entity.className }}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}{{ entity.className }}.{{ prop.propertyName }} == true{% else %}{{ entity.className }}.{{ prop.propertyName }} > 1234{% endif %} }
    
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}> { return Property<{{entity.className}}, {{prop.propertyType}}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }
    
    {% endfor %}
    
    {% for prop in entity.properties where prop.isRelation %}
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>> { return Property(propertyId: {{ prop.modelId.id }}) }
    
    {% endfor %}

    {% if not entity.isValueType %}
    fileprivate func __setId(identifier: EntityId) {
        self.{{ entity.idProperty.propertyName }} = Id(identifier)
    }
    {% endif %}
}

extension ObjectBox.Property where E == {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}.{{ prop.propertyName }} == true{% else %}.{{ prop.propertyName }} > 1234{% endif %} }

    static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}> { return Property<{{entity.className}}, {{prop.propertyType}}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }

    {% endfor %}

    {% for prop in entity.properties where prop.isRelation %}
    static var {{ prop.propertyName }}: Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>> { return Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>>(propertyId: {{ prop.modelId.id }}) }

    {% endfor %}
}


/// Generated service type to handle persisting and reading entity data. Exposed through `{{ entity.className }}.entityInfo`.
{{ visibility }} class {{ entity.className }}Cursor: NSObject, CursorBase {
    {{ visibility }} typealias EntityType = {{ entity.className }}

    override {{ visibility }} required init() {}

    {{ visibility }} func setEntityId(of entity: EntityType, to entityId: EntityId) {
        {% if entity.isValueType %}
        fatalError("Use the struct variants of the put methods on entities of struct {{ entity.className }}.")
        {% else %}
        entity.__setId(identifier: entityId)
        {% endif %}
    }

    {{ visibility }} func entityId(of entity: EntityType) -> EntityId {
        return entity.{{ entity.idProperty.propertyName }}.value
    }

    {{ visibility }} func collect(fromEntity entity: EntityType, propertyCollector: PropertyCollector, store: Store) -> ObjectBox.EntityId {

        {# Avoid defining the `offsets` array when there are no fitting properties #}
        {% if entity.hasStringProperties %}
        var offsets: [(offset: OBXDataOffset, index: UInt16)] = []
        {% for prop in entity.properties %}
        {% if prop.isStringType %}
        offsets.append((propertyCollector.prepare(string: entity.{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }}), 2 + 2 * {{ prop.modelId.id }}))
        {% endif %}
        {% endfor %}
        {% endif %}

        {% for prop in entity.properties where not prop.isStringType and not prop.isObjectId and not prop.isRelation and not prop.isToManyRelation %}
        propertyCollector.collect(entity.{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }})
        {% endfor %}

        {% for prop in entity.properties where prop.isRelation %}
        propertyCollector.collect(entity.{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }}, store: store)
        {% endfor %}

        {% if entity.hasStringProperties %}
        for value in offsets {
            propertyCollector.collect(dataOffset: value.offset, at: value.index)
        }
        {% endif %}

        return entity.{{ entity.idProperty.propertyName }}.value
    }

    {{ visibility }} func createEntity(entityReader: EntityReader, store: Store) -> EntityType {
    {% if entity.isValueType %}
        let entityId: {{ entity.idProperty.propertyType }} = entityReader.read(at: 2 + 2 * {{ entity.idProperty.modelId.id }})
        let entity = {{ entity.className }}(
    {% for prop in entity.properties %}
    {% if prop.isObjectId %}
            id: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store){% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: {{ prop.toManyRelation.relationType }}.backlink(
                                        sourceBox: store.box(for: {{ prop.toManyRelation.relationType }}.Source.self),
                                        sourceProperty: {{ prop.toManyRelation.relationType }}.Source.{{ prop.toManyRelation.backlinkProperty }},
                                        targetId: entityId){% else %}
            {{ prop.propertyName }}: entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}){% endif %}{% if not prop.isLast %}, {% endif %}
    {% endfor %}
        )
    {% else %}
        let entity = {{ entity.className }}()

    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        entity.{{ prop.propertyName }} = entityReader.read(at: 2 + 2 * {{ prop.modelId.id }})
    {% endfor %}

    {% for prop in entity.properties where prop.isRelation %}
        entity.{{ prop.propertyName }} = entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store)
    {% endfor %}

    {% for tmRelation in entity.toManyRelations %}
        entity.{{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
                sourceBox: store.box(for: {{ tmRelation.relationType }}.Source.self),
                sourceProperty: {{ tmRelation.relationType }}.Source.{{ tmRelation.backlinkProperty }},
                targetId: entity.id)
    {% endfor %}
    {% endif %}

        return entity
    }
}

{% if entity.isValueType %}
extension ObjectBox.Box where E == {{ entity.className }} {

    /// Puts the {{ entity.className }} in the box (aka persisting it) returning a copy with the ID updated to the ID it
    /// has been assigned.
    /// If you know the entity has already been persisted, you can use putImmutable() to avoid the cost of the copy.
    ///
    /// - Parameter entity: Object to persist.
    /// - Returns: The stored object. If `entity`'s id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(struct entity: {{ entity.className }}) throws -> {{ entity.className }} {
        let entityId: Id<{{ entity.className }}> = try self.putImmutable(entity)

        return {{ entity.className }}(
        {% for prop in entity.properties %}
        {% if prop.isObjectId %}
            id: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
        {% endfor %}
        )
    }

    /// Puts the {{ entity.className }}s in the box (aka persisting it) returning copies with their IDs updated to the
    /// IDs they've been assigned.
    /// If you know all entities have already been persisted, you can use putImmutable() to avoid the cost of the
    /// copies.
    ///
    /// - Parameter entities: Objects to persist.
    /// - Returns: The stored objects. If any entity's id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(structs entities: [{{ entity.className }}]) throws -> [{{ entity.className }}] {
        let entityIds: [Id<{{ entity.className }}>] = try self.putImmutable(entities)

        return zip(entities, entityIds).map { entity, entityId in
            return {{ entity.className }}(
                {% for prop in entity.properties %}
                {% if prop.isObjectId %}
                id: entityId{% elif prop.isRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
                {% endfor %}
            )
        }
    }
}
{% endif %}

{% endfor %}

fileprivate func modelBytes() -> Data {
    let modelBuilder = ModelBuilder()
    {% for entity in entities %}
    {{ entity.className }}.buildEntity(modelBuilder: modelBuilder)
    {% endfor %}
    return modelBuilder.finish()
}

extension ObjectBox.Store {
    /// A store with a fully configured model. Created by the code generator with your model's metadata in place.
    ///
    /// - Parameters:
    ///   - directoryPath: Directory path to store database files in.
    ///   - maxDbSizeInKByte: Limit of on-disk space for the database files. Default is `1024 * 1024` (1 GiB).
    ///   - fileMode: UNIX-style bit mask used for the database files; default is `0o755`.
    ///   - maxReaders: Maximum amount of concurrent readers, tailored to your use case. Default is `0` (unlimited).
    {{ visibility }} convenience init(directoryPath: String, maxDbSizeInKByte: UInt64 = 1024 * 1024, fileMode: UInt32 = 0o755, maxReaders: UInt32 = 0) throws {
        try self.init(
            modelBytes: modelBytes(),
            directory: directoryPath,
            maxDbSizeInKByte: maxDbSizeInKByte,
            fileMode: fileMode,
            maxReaders: maxReaders)
        registerAllEntities()
    }
    
    {{ visibility }} func registerAllEntities() {
        {% for entity in entities %}
        self.register(entity: {{ entity.className }}.self)
        {% endfor %}
    }
}

// swiftlint:enable all
