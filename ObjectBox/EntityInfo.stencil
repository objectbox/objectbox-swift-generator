// swiftlint:disable all
import ObjectBox

// MARK: - Entity metadata

{% for entity in entities where not entity.isEntitySubclass %}
extension {{ entity.className }}: ObjectBox.Entity {}{% endfor %}
{% for entity in entities %}

extension {{ entity.className }}: ObjectBox.__EntityRelatable {
    {{ visibility }} typealias EntityType = {{ entity.className }}

    {{ visibility }} var _id: Id<{{ entity.className }}> {
        {% if entity.idProperty.propertyType == "UInt64" %}
        return Id<{{ entity.className }}>(self.{{ entity.idProperty.propertyName }})
        {% else %}
        return self.{{ entity.idProperty.propertyName }}
        {% endif %}
    }
}

extension {{ entity.className }}: ObjectBox.EntityInspectable {
    {{ visibility }} typealias EntityBindingType = {{ entity.className }}Binding

    /// Generated metadata used by ObjectBox to persist the entity.
    {{ visibility }} static var entityInfo = ObjectBox.EntityInfo(name: "{{ entity.name }}", id: {{ entity.modelId }})

    {{ visibility }} static var entityBinding = EntityBindingType()

    fileprivate static func buildEntity(modelBuilder: ModelBuilder) throws {
        let entityBuilder = try modelBuilder.entityBuilder(for: {{ entity.className }}.self, id: {{ entity.modelId }}, uid: {{ entity.modelUid }})
        {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        {% set indexParam %}{% if prop.modelIndexId %}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }}{% endif %}{% endset %}
        try entityBuilder.addProperty(name: "{{ prop.name }}", type: {{ prop.unwrappedPropertyType }}.entityPropertyType{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}{{ indexParam }})
        {% endfor %}
        {% for prop in entity.properties where prop.isRelation %}

        try entityBuilder.addToOneRelation(name: "{{ prop.name }}", targetEntityInfo: {{ prop.propertyType }}.Target.entityInfo{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }})
        {% endfor %}

        try entityBuilder.lastProperty(id: {{ entity.lastPropertyId.id }}, uid: {{ entity.lastPropertyId.uid }})
    }
}

extension {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}{{ entity.className }}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}{{ entity.className }}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}{{ entity.className }}.{{ prop.propertyName }} == true{% else %}{{ entity.className }}.{{ prop.propertyName }} > 1234{% endif %} }
    
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}> { return Property<{{entity.className}}, {{prop.propertyType}}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }
    
    {% endfor %}
    
    {% for prop in entity.properties where prop.isRelation %}
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>> { return Property(propertyId: {{ prop.modelId.id }}) }
    
    {% endfor %}

    {% if not entity.isValueType %}
    {% if entity.idProperty.propertyType == "UInt64" %}
    fileprivate func __setId(identifier: ObjectBox.EntityId) {
        self.{{ entity.idProperty.propertyName }} = UInt64(identifier)
    }
    {% else %}
    fileprivate func __setId(identifier: ObjectBox.EntityId) {
        self.{{ entity.idProperty.propertyName }} = Id(identifier)
    }
    {% endif %}
    {% endif %}
}

extension ObjectBox.Property where E == {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}.{{ prop.propertyName }} == true{% else %}.{{ prop.propertyName }} > 1234{% endif %} }

    static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}> { return Property<{{entity.className}}, {{prop.propertyType}}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }

    {% endfor %}

    {% for prop in entity.properties where prop.isRelation %}
    static var {{ prop.propertyName }}: Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>> { return Property<{{entity.className}}, Id<{{ prop.propertyType }}.Target>>(propertyId: {{ prop.modelId.id }}) }

    {% endfor %}
}


/// Generated service type to handle persisting and reading entity data. Exposed through `{{ entity.className }}.EntityBindingType`.
{{ visibility }} class {{ entity.className }}Binding: NSObject, ObjectBox.EntityBinding {
    {{ visibility }} typealias EntityType = {{ entity.className }}

    override {{ visibility }} required init() {}

    {{ visibility }} func setEntityId(of entity: EntityType, to entityId: ObjectBox.EntityId) {
        {% if entity.isValueType %}
        fatalError("Use the struct variants of the put methods on entities of struct {{ entity.className }}.")
        {% else %}
        entity.__setId(identifier: entityId)
        {% endif %}
    }

    {{ visibility }} func entityId(of entity: EntityType) -> ObjectBox.EntityId {
        {% if entity.idProperty.propertyType == "UInt64" %}
        return ObjectBox.EntityId(entity.{{ entity.idProperty.propertyName }})
        {% else %}
        return entity.{{ entity.idProperty.propertyName }}.value
        {% endif %}
    }

    {{ visibility }} func collect(fromEntity entity: EntityType, id: EntityId, propertyCollector: PropertyCollector, store: Store) {

        {# Avoid defining the `offsets` array when there are no fitting properties #}
        {% if entity.hasStringProperties or entity.hasByteVectorProperties %}
        var offsets: [(offset: OBXDataOffset, index: UInt16)] = []
        {% for prop in entity.properties %}
        {% if prop.isStringType %}
        offsets.append((propertyCollector.prepare(string: {{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }}, at: 2 + 2 * {{ prop.modelId.id }}), 2 + 2 * {{ prop.modelId.id }}))
        {% elif prop.isByteVectorType %}
        offsets.append((propertyCollector.prepare(bytes: {{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }}, at: 2 + 2 * {{ prop.modelId.id }}), 2 + 2 * {{ prop.modelId.id }}))
        {% endif %}
        {% endfor %}
        {% endif %}

        propertyCollector.collect(id, at: 2 + 2 * {{ entity.idProperty.modelId.id }})
        {% for prop in entity.properties where not prop.isStringType and not prop.isByteVectorType and not prop.isObjectId and not prop.isRelation and not prop.isToManyRelation %}
        propertyCollector.collect({{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }}, at: 2 + 2 * {{ prop.modelId.id }})
        {% endfor %}

        {% for prop in entity.properties where prop.isRelation %}
        propertyCollector.collect(entity.{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }}, store: store)
        {% endfor %}

        {% if entity.hasStringProperties or entity.hasByteVectorProperties %}
        for value in offsets {
            propertyCollector.collect(dataOffset: value.offset, at: value.index)
        }
        {% endif %}
    }

    {{ visibility }} func createEntity(entityReader: EntityReader, store: Store) -> EntityType {
    {% if entity.isValueType %}
    let entityId: {{ entity.idProperty.propertyType }} = {{ entity.idProperty.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ entity.idProperty.modelId.id }}){{ entity.idProperty.conversionSuffix }}
        let entity = {{ entity.className }}(
    {% for prop in entity.properties %}
    {% if prop.isObjectId %}
            {{ prop.propertyName }}: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store){{ prop.conversionSuffix }}{% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: {{ prop.toManyRelation.relationType }}.backlink(
                                        sourceBox: store.box(for: {{ prop.toManyRelation.relationType }}.Source.self),
                                        sourceProperty: {{ prop.toManyRelation.relationType }}.Source.{{ prop.toManyRelation.backlinkProperty }},
                                        targetId: entityId){% else %}
            {{ prop.propertyName }}: {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}){{ prop.conversionSuffix }}{% endif %}{% if not prop.isLast %}, {% endif %}
    {% endfor %}
        )
    {% else %}
        let entity = {{ entity.className }}()

    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        entity.{{ prop.propertyName }} = {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}){{ prop.conversionSuffix }}
    {% endfor %}

    {% for prop in entity.properties where prop.isRelation %}
        entity.{{ prop.propertyName }} = entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store)
    {% endfor %}

    {% for tmRelation in entity.toManyRelations %}
        entity.{{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
                sourceBox: store.box(for: {{ tmRelation.relationType }}.Source.self),
                sourceProperty: {{ tmRelation.relationType }}.Source.{{ tmRelation.backlinkProperty }},
                targetId: entity.id)
    {% endfor %}
    {% endif %}

        return entity
    }
}

{% if entity.isValueType %}
extension ObjectBox.Box where E == {{ entity.className }} {

    /// Puts the {{ entity.className }} in the box (aka persisting it) returning a copy with the ID updated to the ID it
    /// has been assigned.
    /// If you know the entity has already been persisted, you can use putImmutable() to avoid the cost of the copy.
    ///
    /// - Parameter entity: Object to persist.
    /// - Returns: The stored object. If `entity`'s id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(struct entity: {{ entity.className }}) throws -> {{ entity.className }} {
        let entityId: Id<{{ entity.className }}> = try self.putImmutable(entity)

        return {{ entity.className }}(
        {% for prop in entity.properties %}
        {% if prop.isObjectId %}
            id: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
        {% endfor %}
        )
    }

    /// Puts the {{ entity.className }}s in the box (aka persisting it) returning copies with their IDs updated to the
    /// IDs they've been assigned.
    /// If you know all entities have already been persisted, you can use putImmutable() to avoid the cost of the
    /// copies.
    ///
    /// - Parameter entities: Objects to persist.
    /// - Returns: The stored objects. If any entity's id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(structs entities: [{{ entity.className }}]) throws -> [{{ entity.className }}] {
        let entityIds: [Id<{{ entity.className }}>] = try self.putImmutable(entities)
        var newEntities = Array<{{ entity.className }}>()

        for i in 0 ..< min(entities.count, entityIds.count) {
            let entity = entities[i]
            let entityId = entityIds[i]

            newEntities.append({{ entity.className }}(
                {% for prop in entity.properties %}
                {% if prop.isObjectId %}
                id: entityId{% elif prop.isRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
                {% endfor %}
            ))
        }

        return newEntities
    }
}
{% endif %}

{% endfor %}

// MARK: - Store setup

fileprivate func cModel() throws -> OpaquePointer {
    let modelBuilder = try ModelBuilder()
    {% for entity in entities %}
    try {{ entity.className }}.buildEntity(modelBuilder: modelBuilder)
    {% endfor %}
    modelBuilder.lastEntity(id: {{ lastEntityId.id }}, uid: {{ lastEntityId.uid }})
    {% if lastIndexId.id != 0 %}modelBuilder.lastIndex(id: {{ lastIndexId.id }}, uid: {{ lastIndexId.uid }}){% endif %}
    {% if lastRelationId.id != 0 %}modelBuilder.lastRelation(id: {{ lastRelationId.id }}, uid: {{ lastRelationId.uid }}){% endif %}
    return modelBuilder.finish()
}

extension ObjectBox.Store {
    /// A store with a fully configured model. Created by the code generator with your model's metadata in place.
    ///
    /// - Parameters:
    ///   - directoryPath: Directory path to store database files in.
    ///   - maxDbSizeInKByte: Limit of on-disk space for the database files. Default is `1024 * 1024` (1 GiB).
    ///   - fileMode: UNIX-style bit mask used for the database files; default is `0o755`.
    ///   - maxReaders: Maximum amount of concurrent readers, tailored to your use case. Default is `0` (unlimited).
    {{ visibility }} convenience init(directoryPath: String, maxDbSizeInKByte: UInt64 = 1024 * 1024, fileMode: UInt32 = 0o755, maxReaders: UInt32 = 0) throws {
        try self.init(
            model: try cModel(),
            directory: directoryPath,
            maxDbSizeInKByte: maxDbSizeInKByte,
            fileMode: fileMode,
            maxReaders: maxReaders)
    }
}

// swiftlint:enable all
