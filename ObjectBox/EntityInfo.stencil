// swiftlint:disable all
import ObjectBox

// MARK: - Entity metadata

{% for entity in entities where not entity.isEntitySubclass %}
extension {{ entity.className }}: ObjectBox.Entity {}{% endfor %}
{% for entity in entities %}

extension {{ entity.className }}: ObjectBox.__EntityRelatable {
    {{ visibility }} typealias EntityType = {{ entity.className }}

    {{ visibility }} var _id: EntityId<{{ entity.className }}> {
        return EntityId<{{ entity.className }}>(self.{{ entity.idProperty.propertyName }}.value)
    }
}

extension {{ entity.className }}: ObjectBox.EntityInspectable {
    {{ visibility }} typealias EntityBindingType = {{ entity.className }}Binding

    /// Generated metadata used by ObjectBox to persist the entity.
    {{ visibility }} static var entityInfo = ObjectBox.EntityInfo(name: "{{ entity.name }}", id: {{ entity.modelId }})

    {{ visibility }} static var entityBinding = EntityBindingType()

    fileprivate static func buildEntity(modelBuilder: ObjectBox.ModelBuilder) throws {
        let entityBuilder = try modelBuilder.entityBuilder(for: {{ entity.className }}.self, id: {{ entity.modelId }}, uid: {{ entity.modelUid }})
        {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        {% set indexParam %}{% if prop.modelIndexId %}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }}{% endif %}{% endset %}
        try entityBuilder.addProperty(name: "{{ prop.name }}", type: {{ prop.unwrappedPropertyType }}.entityPropertyType{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}{{ indexParam }})
        {% endfor %}
        {% for prop in entity.properties where prop.isRelation %}
        try entityBuilder.addToOneRelation(name: "{{ prop.name }}", targetEntityInfo: {{ prop.propertyType }}.Target.entityInfo{{ prop.flagsList }}, id: {{ prop.modelId.id }}, uid: {{ prop.modelId.uid }}, indexId: {{ prop.modelIndexId.id }}, indexUid: {{ prop.modelIndexId.uid }})
        {% endfor %}
        {% for tmRelation in entity.toManyRelations where not tmRelation.backlinkProperty %}
        try entityBuilder.addToManyRelation(id: {{ tmRelation.modelId.id }}, uid: {{ tmRelation.modelId.uid }},
                                            targetId: {{ tmRelation.targetId.id }}, targetUid: {{ tmRelation.targetId.uid }})
        {% endfor %}

        try entityBuilder.lastProperty(id: {{ entity.lastPropertyId.id }}, uid: {{ entity.lastPropertyId.uid }})
    }
}

extension {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}{{ entity.className }}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}{{ entity.className }}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}{{ entity.className }}.{{ prop.propertyName }} == true{% else %}{{ entity.className }}.{{ prop.propertyName }} > 1234{% endif %} }
    
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}, {% if prop.isObjectId %}{{prop.propertyType}}{% else %}Void{% endif %}> { return Property<{{entity.className}}, {{prop.propertyType}}, {% if prop.isObjectId %}{{prop.propertyType}}{% else %}Void{% endif %}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }
    
    {% endfor %}
    {% for prop in entity.properties where prop.isRelation %}
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, EntityId<{{ prop.propertyType }}.Target>, {{ prop.propertyType }}.Target> { return Property(propertyId: {{ prop.modelId.id }}) }

    {% endfor %}
    {% for prop in entity.properties where prop.isToManyRelation %}
    /// Use `{{entity.className}}.{{ prop.propertyName }}` to refer to this ToMany relation property in queries,
    /// like when using `QueryBuilder.and(property:, conditions:)`.

    {{ visibility }} static var {{ prop.propertyName }}: ToManyProperty<{{ prop.toManyRelation.relationTargetType }}> { return ToManyProperty({% if prop.toManyRelation.backlinkPropertyId %}.valuePropertyId({{ prop.toManyRelation.backlinkPropertyId.id }}){% else %}{% if prop.toManyRelation.backlinkProperty %}.backlinkRelationId{% else %}.relationId{% endif %}({{ prop.toManyRelation.modelId.id }}){% endif %}) }

    {% endfor %}
    {% if entity.idProperty.isMutable %}

    {% if entity.idProperty.propertyType == "UInt64" or entity.idProperty.propertyType == "Id" %}
    fileprivate{% if entity.isValueType %} mutating{% endif %} func __setId(identifier: ObjectBox.Id) {
        self.{{ entity.idProperty.propertyName }} = {{ entity.idProperty.propertyType }}(identifier)
    }
    {% else %}
    fileprivate{% if entity.isValueType %} mutating{% endif %} func __setId(identifier: ObjectBox.Id) {
        self.{{ entity.idProperty.propertyName }} = EntityId(identifier)
    }
    {% endif %}
    {% endif %}
}

extension ObjectBox.Property where E == {{ entity.className }} {
    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
    /// Generated entity property information.
    ///
    /// You may want to use this in queries to specify fetch conditions, for example:
    ///
    ///     box.query { {% if prop.isObjectId %}.{{ prop.propertyName }} == myId{% elif prop.isStringType %}.{{ prop.propertyName }}.startsWith("X"){% elif prop.propertyType == "Bool" %}.{{ prop.propertyName }} == true{% else %}.{{ prop.propertyName }} > 1234{% endif %} }

    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, {{prop.propertyType}}, {% if prop.isObjectId %}{{prop.propertyType}}{% else %}Void{% endif %}> { return Property<{{entity.className}}, {{prop.propertyType}}, {% if prop.isObjectId %}{{prop.propertyType}}{% else %}Void{% endif %}>(propertyId: {{ prop.modelId.id }}, isPrimaryKey: {{ prop.isObjectId }}) }

    {% endfor %}
    {% for prop in entity.properties where prop.isRelation %}
    {{ visibility }} static var {{ prop.propertyName }}: Property<{{entity.className}}, {{ prop.propertyType }}.Target.EntityBindingType.IdType, {{ prop.propertyType }}.Target> { return Property<{{entity.className}}, {{ prop.propertyType }}.Target.EntityBindingType.IdType, {{ prop.propertyType }}.Target>(propertyId: {{ prop.modelId.id }}) }

    {% endfor %}
    {% for prop in entity.properties where prop.isToManyRelation %}
    /// Use `.{{ prop.propertyName }}` to refer to this ToMany relation property in queries, like when using
    /// `QueryBuilder.and(property:, conditions:)`.

    {{ visibility }} static var {{ prop.propertyName }}: ToManyProperty<{{ prop.toManyRelation.relationTargetType }}> { return ToManyProperty({% if prop.toManyRelation.backlinkPropertyId %}.valuePropertyId({{ prop.toManyRelation.backlinkPropertyId.id }}){% else %}{% if prop.toManyRelation.backlinkProperty %}.backlinkRelationId{% else %}.relationId{% endif %}({{ prop.toManyRelation.modelId.id }}){% endif %}) }

    {% endfor %}
}


/// Generated service type to handle persisting and reading entity data. Exposed through `{{ entity.className }}.EntityBindingType`.
{{ visibility }} class {{ entity.className }}Binding: NSObject, ObjectBox.EntityBinding {
    {{ visibility }} typealias EntityType = {{ entity.className }}
    {{ visibility }} typealias IdType = {{ entity.idProperty.propertyType }}

    override {{ visibility }} required init() {}

    {% if entity.isValueType and entity.idProperty.isMutable %}
    {{ visibility }} func setStructEntityId(of entity: inout EntityType, to entityId: ObjectBox.Id) {
        entity.__setId(identifier: entityId)
    }
    {% elif not entity.isValueType %}
    {{ visibility }} func setEntityIdUnlessStruct(of entity: EntityType, to entityId: ObjectBox.Id) {
        entity.__setId(identifier: entityId)
    }
    {% endif %}

    {{ visibility }} func entityId(of entity: EntityType) -> ObjectBox.Id {
        return entity.{{ entity.idProperty.propertyName }}.value
    }

    {{ visibility }} func collect(fromEntity entity: EntityType, id: ObjectBox.Id,
                                  propertyCollector: ObjectBox.FlatBufferBuilder, store: ObjectBox.Store) {
        {% for prop in entity.properties %}
        {% if prop.isStringType %}
        let propertyOffset_{{ prop.propertyName }} = propertyCollector.prepare(string: {{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }})
        {% elif prop.isByteVectorType %}
        let propertyOffset_{{ prop.propertyName }} = propertyCollector.prepare(bytes: {{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }})
        {% endif %}
        {% endfor %}

        propertyCollector.collect(id, at: 2 + 2 * {{ entity.idProperty.modelId.id }})
        {% for prop in entity.properties where not prop.isStringType and not prop.isByteVectorType and not prop.isObjectId and not prop.isRelation and not prop.isToManyRelation %}
        propertyCollector.collect({{ prop.unConversionPrefix }}entity.{{ prop.propertyName }}{{ prop.unConversionSuffix }}, at: 2 + 2 * {{ prop.modelId.id }})
        {% endfor %}
        {% for prop in entity.properties where prop.isRelation %}
        propertyCollector.collect(entity.{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }}, store: store)
        {% endfor %}
        {% for prop in entity.properties %}
        {% if prop.isStringType or prop.isByteVectorType %}
        propertyCollector.collect(dataOffset: propertyOffset_{{ prop.propertyName }}, at: 2 + 2 * {{ prop.modelId.id }})
        {% endif %}
        {% endfor %}
    }

    {# If a newly created object has an empty array in its ToMany relation, take that as "unloaded" and don't assign an
    empty array to the relation object when we associate it with a box after writing. Otherwise relations would always
    cache the empty list, and you couldn't access a relation unless you reset() it first. There is no way to detect
    whether requesting a lazy property would cause it to be loaded, but since an object that hasn't been written yet
    can't have ever written its relations, an empty list is identical to "never loaded" for all intents and purposes. #}
  {% if not entity.isValueType %}
  {% if entity.toManyRelations.count != 0 or entity.relations.count != 0 %}
    {{ visibility }} func postPut(fromEntity entity: EntityType, id: ObjectBox.Id, store: ObjectBox.Store) {
        if entityId(of: entity) == 0 { // Written for first time? Attach ToMany relations:
        {% for tmRelation in entity.toManyRelations %}
          {% if not tmRelation.backlinkProperty %}
            let {{ tmRelation.relationName }} = {{ tmRelation.relationType }}.relation(
                sourceId: EntityId<{{ entity.className }}>(id.value),
                targetBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
                relationId: {{ tmRelation.modelId.id }})
          {% elif tmRelation.backlinkProperty and tmRelation.isToManyBacklink %}
            let {{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
                sourceBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
                targetId: EntityId<{{ entity.className }}>(id.value),
                relationId: {{ tmRelation.modelId.id }})
          {% else %}
            let {{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
                sourceBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
                sourceProperty: {{ tmRelation.relationType }}.ReferencedType.{{ tmRelation.backlinkProperty }},
                targetId: EntityId<{{ entity.className }}>(id.value))
          {% endif %}
            if !entity.{{ tmRelation.relationName }}.isEmpty {
                {{ tmRelation.relationName }}.replace(entity.{{ tmRelation.relationName }})
            }
            entity.{{ tmRelation.relationName }} = {{ tmRelation.relationName }}
        {% endfor %}
        {% for relation in entity.relations %}
            entity.{{ relation.property.name }}.attach(to: store.box(for: {{ relation.relationTargetType }}.self))
        {% endfor %}
        }
    }
  {% endif %}
  {% endif %}
  {% if entity.relations.count != 0 %}
    {{ visibility }} func setToOneRelation(_ propertyId: obx_schema_id, of entity: EntityType, to entityId: ObjectBox.Id?) {
        switch propertyId {
      {% for relation in entity.relations %}
            case {{ relation.property.modelId.id }}:
                entity.{{ relation.property.name }}.targetId = (entityId != nil) ? EntityId<{{ relation.relationTargetType }}>(entityId!) : nil
      {% endfor %}
            default:
                fatalError("Attempt to change nonexistent ToOne relation with ID \(propertyId)")
        }
    }
  {% endif %}
    {{ visibility }} func createEntity(entityReader: ObjectBox.FlatBufferReader, store: ObjectBox.Store) -> EntityType {
    {% if entity.isValueType %}
        let entityId: {{ entity.idProperty.propertyType }} = {{ entity.idProperty.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ entity.idProperty.modelId.id }}){{ entity.idProperty.conversionSuffix }}
        let entity = {{ entity.className }}(
    {% for prop in entity.properties %}
    {% if prop.isObjectId %}
            {{ prop.propertyName }}: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store){{ prop.conversionSuffix }}{% elif prop.isToManyRelation and not prop.toManyRelation.backlinkProperty %}
            {{ prop.propertyName }}: {{ prop.toManyRelation.relationType }}.relation(
                            sourceId: EntityId<{{ entity.className }}>(entityId.value),
                            targetBox: store.box(for: {{ prop.toManyRelation.relationType }}.ReferencedType.self),
                            relationId: {{ prop.toManyRelation.modelId.id }}){% elif prop.isToManyRelation and prop.toManyRelation.isToManyBacklink %}
            {{ prop.propertyName }}: {{ prop.toManyRelation.relationType }}.backlink(
                            sourceBox: store.box(for: {{ prop.toManyRelation.relationType }}.ReferencedType.self),
                            targetId: EntityId<{{ entity.className }}>(entityId.value),
                            relationId: {{ prop.toManyRelation.modelId.id }}){% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: {{ prop.toManyRelation.relationType }}.backlink(
                            sourceBox: store.box(for: {{ prop.toManyRelation.relationType }}.ReferencedType.self),
                            sourceProperty: {{ prop.toManyRelation.relationType }}.ReferencedType.{{ prop.toManyRelation.backlinkProperty }},
                            targetId: EntityId<{{ entity.className }}>(entityId.value)){% else %}
            {{ prop.propertyName }}: {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}){{ prop.conversionSuffix }}{% endif %}{% if not prop.isLast %}, {% endif %}
    {% endfor %}
        )
    {% else %}
        let entity = {{ entity.className }}()

    {% for prop in entity.properties where not prop.isRelation and not prop.isToManyRelation %}
        entity.{{ prop.propertyName }} = {{ prop.conversionPrefix }}entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}){{ prop.conversionSuffix }}
    {% endfor %}

    {% for prop in entity.properties where prop.isRelation %}
        entity.{{ prop.propertyName }} = entityReader.read(at: 2 + 2 * {{ prop.modelId.id }}, store: store)
    {% endfor %}
    {% for tmRelation in entity.toManyRelations %}
      {% if not tmRelation.backlinkProperty %}
        entity.{{ tmRelation.relationName }} = {{ tmRelation.relationType }}.relation(
            sourceId: EntityId<{{ entity.className }}>(entity.{{ entity.idProperty.name }}.value),
            targetBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
            relationId: {{ tmRelation.modelId.id }})
      {% elif tmRelation.isToManyBacklink %}
        entity.{{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
            sourceBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
            targetId: EntityId<{{ entity.className }}>(entity.{{ entity.idProperty.name }}.value),
            relationId: {{ tmRelation.modelId.id }})
      {% else %}
        entity.{{ tmRelation.relationName }} = {{ tmRelation.relationType }}.backlink(
            sourceBox: store.box(for: {{ tmRelation.relationType }}.ReferencedType.self),
            sourceProperty: {{ tmRelation.relationType }}.ReferencedType.{{ tmRelation.backlinkProperty }},
            targetId: EntityId<{{ entity.className }}>(entity.{{ entity.idProperty.name }}.value))
      {% endif %}
    {% endfor %}
    {% endif %}
        return entity
    }
}

{% if entity.isValueType %}
extension ObjectBox.Box where E == {{ entity.className }} {

    /// Puts the {{ entity.className }} in the box (aka persisting it) returning a copy with the ID updated to the ID it
    /// has been assigned.
    /// If you know the entity has already been persisted, you can use put() to avoid the cost of the copy.
    ///
    /// - Parameter entity: Object to persist.
    /// - Returns: The stored object. If `entity`'s id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(struct entity: {{ entity.className }}) throws -> {{ entity.className }} {
        let entityId: {{ entity.className }}.EntityBindingType.IdType = try self.put(entity)

        return {{ entity.className }}(
        {% for prop in entity.properties %}
        {% if prop.isObjectId %}
            id: entityId{% elif prop.isRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
            {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
        {% endfor %}
        )
    }

    /// Puts the {{ entity.className }}s in the box (aka persisting it) returning copies with their IDs updated to the
    /// IDs they've been assigned.
    /// If you know all entities have already been persisted, you can use put() to avoid the cost of the
    /// copies.
    ///
    /// - Parameter entities: Objects to persist.
    /// - Returns: The stored objects. If any entity's id is 0, an ID is generated.
    /// - Throws: ObjectBoxError errors for database write errors.
    func put(structs entities: [{{ entity.className }}]) throws -> [{{ entity.className }}] {
        let entityIds: [{{ entity.className }}.EntityBindingType.IdType] = try self.putAndReturnIDs(entities)
        var newEntities = [{{ entity.className }}]()
        newEntities.reserveCapacity(entities.count)

        for i in 0 ..< min(entities.count, entityIds.count) {
            let entity = entities[i]
            let entityId = entityIds[i]

            newEntities.append({{ entity.className }}(
                {% for prop in entity.properties %}
                {% if prop.isObjectId %}
                id: entityId{% elif prop.isRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% elif prop.isToManyRelation %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% else %}
                {{ prop.propertyName }}: entity.{{ prop.propertyName }}{% endif %}{% if not prop.isLast %}, {% endif %}
                {% endfor %}
            ))
        }

        return newEntities
    }
}
{% endif %}

{% endfor %}
/// Helper function that allows calling Enum(rawValue: value) with a nil value, which will return nil.
fileprivate func optConstruct<T: RawRepresentable>(_ type: T.Type, rawValue: T.RawValue?) -> T? {
    guard let rawValue = rawValue else { return nil }
    return T(rawValue: rawValue)
}

// MARK: - Store setup

fileprivate func cModel() throws -> OpaquePointer {
    let modelBuilder = try ObjectBox.ModelBuilder()
    {% for entity in entities %}
    try {{ entity.className }}.buildEntity(modelBuilder: modelBuilder)
    {% endfor %}
    modelBuilder.lastEntity(id: {{ lastEntityId.id }}, uid: {{ lastEntityId.uid }})
    {% if lastIndexId.id != 0 %}modelBuilder.lastIndex(id: {{ lastIndexId.id }}, uid: {{ lastIndexId.uid }}){% endif %}
    {% if lastRelationId.id != 0 %}modelBuilder.lastRelation(id: {{ lastRelationId.id }}, uid: {{ lastRelationId.uid }}){% endif %}
    return modelBuilder.finish()
}

extension ObjectBox.Store {
    /// A store with a fully configured model. Created by the code generator with your model's metadata in place.
    ///
    /// - Parameters:
    ///   - directoryPath: Directory path to store database files in.
    ///   - maxDbSizeInKByte: Limit of on-disk space for the database files. Default is `1024 * 1024` (1 GiB).
    ///   - fileMode: UNIX-style bit mask used for the database files; default is `0o755`.
    ///   - maxReaders: Maximum amount of concurrent readers, tailored to your use case. Default is `0` (unlimited).
    {{ visibility }} convenience init(directoryPath: String, maxDbSizeInKByte: UInt64 = 1024 * 1024, fileMode: UInt32 = 0o755, maxReaders: UInt32 = 0) throws {
        try self.init(
            model: try cModel(),
            directory: directoryPath,
            maxDbSizeInKByte: maxDbSizeInKByte,
            fileMode: fileMode,
            maxReaders: maxReaders)
    }
}

// swiftlint:enable all
